<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  CodingCow </title>

 
  
    <link rel="icon" href="/images/favicon.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-nav">        
   
    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <!-- <a class="header-logo" href="/"></a> -->

    <div class="header-menu">          
              
            

              <a class="header-menu-link" id="header-menu-home" href="/">首页</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-archives" href="/archives">归档</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-categories" href="/categories">分类</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-tags" href="/tags">标签</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-about" href="/about">关于</a>     

            
            
            

              <a class="iconfont icon-menu-search header-menu-link" id="header-menu-search"></a>

            
                
    </div>  
    
  </nav>
</header>   

      <div class="container">       
          
          
            <section class="main">  
          

          


<div class="profile sildeUpMin">

		
		<a href="/">
			<img class="avatar" src="/images/header.jpg">
		</a>
		
		<p class="author">Austin</p>
		
		<div class="social">
   		      		
		<a target="_blank" class="social-links" href="https://github.com/orchoe">		
			<i class="iconfont icon-Github"></i>
		</a>	
	    
    	</div>		
</div>

      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title" href="/2017/12/21/新建文件夹/HashMap原理分析(JDK1.8)/">HashMap原理分析(JDK1.8)</a>  
	       
		 

		<div class="article-meta">
		
		12月 21, 2017

		
			<span class="iconfont icon-star"></span>		 
			            
			<a class="article-tag" href="/tags/HashMap/">HashMap</a>           
			
		
		</div>

	</div>


	

    
	<div class="article-excerpt">	
		
			<p>&nbsp; &nbsp; &nbsp; &nbsp; HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。HashMap类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<h2 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。<br><img src="/images/hashmap.png" alt="Alt text"><br>&nbsp; &nbsp; &nbsp; &nbsp; 从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。<br>
		  	  
	</p></div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2017/12/21/新建文件夹/HashMap原理分析(JDK1.8)/">阅读更多</a> 	</div>	
    
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title" href="/2017/12/18/MySQL中的几种引擎介绍/">MySQL中的几种引擎介绍</a>  
	       
		 

		<div class="article-meta">
		
		12月 18, 2017

		
			<span class="iconfont icon-star"></span>		 
			            
			<a class="article-tag" href="/tags/MySQL/">MySQL</a>           
			
		
		</div>

	</div>


	

    
	<div class="article-excerpt">	
		
			<h1 id="（￣∞￣）"><a href="#（￣∞￣）" class="headerlink" title="（￣∞￣）"></a>（￣∞￣）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。<strong>MySql的核心就是存储引擎</strong>。</p>
<p><strong>存储引擎查看</strong></p>
<p>MySQL给开发者提供了查询存储引擎的功能，我这里使用的是MySQL5.5，可以使用：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ENGINES</span></span><br></pre></td></tr></table></figure></p>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2017/12/18/MySQL中的几种引擎介绍/">阅读更多</a> 	</div>	
    
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title" href="/2017/12/17/浅谈线程中的wait()和sleep()/">浅谈线程中的 wait() 和 sleep()</a>  
	       
		 

		<div class="article-meta">
		
		12月 17, 2017

		
			<span class="iconfont icon-star"></span>		 
			            
			<a class="article-tag" href="/tags/Thread/">Thread</a>           
			
		
		</div>

	</div>


	

    
	<div class="article-excerpt">	
		
			<h1 id="（￣︶￣）"><a href="#（￣︶￣）" class="headerlink" title="\（￣︶￣）/"></a>\（￣︶￣）/</h1><p>&nbsp; &nbsp; &nbsp; &nbsp; wait() 方法和 sleep() 方法都可以使线程挂起，起到的效果看似相同，但其实二者之间存在许多差异。 </p>
<h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><p>(1) 都可以使线程在程序的调用处阻塞指定的毫秒数，然后回到可运行状态。</p>
<p>(2) wait() 和 sleep() 都可以通过 interrupt() 方法打断线程的暂停状态（不建议使用该方法）。</p>
<blockquote>
<p>注：对线程对象调用 interrupt() 方法时，如果该线程对象处于 wait / sleep / join 状态时，该线程会立刻抛出 InterruptedException，在catch() {} 中直接 return 即可安全地结束线程；如果该线程正在执行的是普通代码，那么该线程不会抛出 InterruptedException。<br>
		  	  
	</p></blockquote></div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2017/12/17/浅谈线程中的wait()和sleep()/">阅读更多</a> 	</div>	
    
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title" href="/2017/10/21/Dubbo的集群容错和负载均衡/">Dubbo的集群容错和负载均衡</a>  
	       
		 

		<div class="article-meta">
		
		10月 21, 2017

		
			<span class="iconfont icon-star"></span>		 
			            
			<a class="article-tag" href="/tags/Dubbo/">Dubbo</a>           
			
		
		</div>

	</div>


	

    
	<div class="article-excerpt">	
		
			<h1 id="o-O"><a href="#o-O" class="headerlink" title="o_O"></a>o_O</h1><h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; Dubbo中常见容错机制包括 failover，failsafe，failfase，failback，forking，缺省为failover重试。</p>
<p><font color="#1A75B1"><strong>Failover  &nbsp;失败自动切换</strong></font><br>当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过retries=”2”来设置重试次数(不含第一次)。</p>
<p><font color="#1A75B1"><strong>Failfast  &nbsp;快速失败</strong></font><br>只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
<p><font color="#1A75B1"><strong>Failsafe  &nbsp;失败安全</strong></font><br>出现异常时，直接忽略，通常用于写入审计日志等操作，调用信息丢失。可用于生产环境 Monitor。<br>
		  	  
	</p></div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2017/10/21/Dubbo的集群容错和负载均衡/">阅读更多</a> 	</div>	
    
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title" href="/2017/10/19/数据库的事务隔离级别/">数据库的事务隔离级别</a>  
	       
		 

		<div class="article-meta">
		
		10月 19, 2017

		
			<span class="iconfont icon-star"></span>		 
			            
			<a class="article-tag" href="/tags/Database/">Database</a>           
			            
			<a class="article-tag" href="/tags/Transaction/">Transaction</a>           
			
		
		</div>

	</div>


	

    
	<div class="article-excerpt">	
		
			<h1 id="￣ε￣；"><a href="#￣ε￣；" class="headerlink" title="(￣ε￣；)"></a>(￣ε￣；)</h1><h2 id="事务的四个特性"><a href="#事务的四个特性" class="headerlink" title="事务的四个特性"></a>事务的四个特性</h2><p>数据库事务（Transaction）是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。一方面，当多个应用程序并发访问数据库时，事务可以在应用程序间提供一个隔离方法，防止互相干扰。另一方面，事务为数据库操作序列提供了一个从失败恢复正常的方法。</p>
<p>事务具有四个特性：原子性（Atomicity）、一致性（Consistency）、隔离型（Isolation）、持久性（Durability），简称ACID。</p>
<p>1 原子性（Atomicity）<br>事务的原子性是指事务中的操作不可拆分，只允许全部执行或者全部不执行。<br>
		  	  
	</p></div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2017/10/19/数据库的事务隔离级别/">阅读更多</a> 	</div>	
    
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title" href="/2017/10/06/悲观锁和乐观锁/">悲观锁和乐观锁</a>  
	       
		 

		<div class="article-meta">
		
		10月 06, 2017

		
			<span class="iconfont icon-star"></span>		 
			            
			<a class="article-tag" href="/tags/Database/">Database</a>           
			            
			<a class="article-tag" href="/tags/Lock/">Lock</a>           
			
		
		</div>

	</div>


	

    
	<div class="article-excerpt">	
		
			<h1 id=""><a href="#" class="headerlink" title="@_@"></a>@_@</h1><p>&nbsp; &nbsp; &nbsp; &nbsp;悲观锁还是乐观锁是人们定义的一种概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcached、hibernate、tair等都有类似的概念。<br>&nbsp; &nbsp; &nbsp; &nbsp;针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。<br>&nbsp;&nbsp;&nbsp;&nbsp;下面具体介绍一下悲观锁和乐观锁。<br>
		  	  
	</p></div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2017/10/06/悲观锁和乐观锁/">阅读更多</a> 	</div>	
    
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title" href="/2017/10/05/数据库的锁机制/">数据库的锁机制</a>  
	       
		 

		<div class="article-meta">
		
		10月 05, 2017

		
			<span class="iconfont icon-star"></span>		 
			            
			<a class="article-tag" href="/tags/Database/">Database</a>           
			            
			<a class="article-tag" href="/tags/Lock/">Lock</a>           
			
		
		</div>

	</div>


	

    
	<div class="article-excerpt">	
		
			<h1 id=""><a href="#" class="headerlink" title="(=^_^=)"></a>(=^_^=)</h1><p>&nbsp; &nbsp; &nbsp; &nbsp;在计算机科学中，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制（Concurrency Control）是确保及时纠正由并发操作导致的错误的一种机制。<br>&nbsp; &nbsp; &nbsp; &nbsp;数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。下面举例说明并发操作带来的数据不一致性问题：<br>
		  	  
	</p></div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2017/10/05/数据库的锁机制/">阅读更多</a> 	</div>	
    
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title" href="/2017/09/21/JVM的类加载机制/">JVM的类加载机制</a>  
	       
		 

		<div class="article-meta">
		
		9月 21, 2017

		
			<span class="iconfont icon-star"></span>		 
			            
			<a class="article-tag" href="/tags/JVM/">JVM</a>           
			
		
		</div>

	</div>


	

    
	<div class="article-excerpt">	
		
			<h1 id="（￣Q￣）╯"><a href="#（￣Q￣）╯" class="headerlink" title="（￣Q￣）╯"></a>（￣Q￣）╯</h1><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>如下图所示，JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。<br><img src="/images/jvm/loadclass.png" alt="Alt text"><br>
		  	  
	</p></div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2017/09/21/JVM的类加载机制/">阅读更多</a> 	</div>	
    
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title" href="/2017/09/16/JVM中的垃圾收集算法及回收器/">JVM中的垃圾收集算法及回收器</a>  
	       
		 

		<div class="article-meta">
		
		9月 16, 2017

		
			<span class="iconfont icon-star"></span>		 
			            
			<a class="article-tag" href="/tags/JVM/">JVM</a>           
			
		
		</div>

	</div>


	

    
	<div class="article-excerpt">	
		
			<h1 id="（-￣▽￣-）"><a href="#（-￣▽￣-）" class="headerlink" title="（#￣▽￣#）"></a>（#￣▽￣#）</h1><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h3><p>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。<br>标记清除算法主要不足有两个：一是效率问题，标记和清除两个过程效率都不高；另一个是标记清除之后会产生大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发full gc。<br>
		  	  
	</p></div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2017/09/16/JVM中的垃圾收集算法及回收器/">阅读更多</a> 	</div>	
    
</article>     
     	
  

 

  <nav class="paginator scrollIn">
   
      <a class="prev" href="/"> 
      <i class="iconfont icon-left"></i>
      上一页
      </a>
   


   <span class="page-number">
   Page 2.
   </span>

   
  </nav> 
  


          </section> 
      </div>            
    
    <a id="backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    

        
        <div class="search-container sildeUpMin">


            <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">  
            <span class="search-cancel iconfont icon-cancel"></span>
          
            </div>
              
            <div id="search-result" class="search-result"></div>

        </div>
 

     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src="/images/favicon.png">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/categories">分类
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
				
		2017-
		
		2018		
	
		&nbsp;CodingCow
		<br>

		Powered By
		<a href="https://hexo.io/" target="_blank">Hexo</a>
		<p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p>
		</div>			
	 
</footer>   

  

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>